;;;; accounting.lisp

(in-package #:accounting)

;;; "accounting" goes here. Hacks and glory await!

(defclass named-entry ()
  ((name :accessor name :initarg :name)
   )
  )
(defclass account (named-entry)
  ((children :accessor children :initform nil)
   (parent :accessor parent :initform nil :initarg :parent)
   (entries :accessor entries :initform (make-list 0))
   )
  )
(defclass account-entry ()
  ((amount :accessor amount :initarg :amount :type 'decimal)
   (date   :accessor date   :initarg :date   :type 'timestamp)
   (debitp :accessor debitp :initarg :debitp)
   (legend :accessor legend :initarg :legend :type 'string)
   (posted :accessor posted :initform nil)
   )
  )
(defclass journal ()
  ((ledger :accessor ledger :initarg :ledger :type 'ledger)
   )
  )
(deftype ledger (l)
  `(and (account ,l)
        (satisfies no-parent))
  )
(defun no-parent (self)
  (null (parent self))
  )
(defclass batch ()
  ((ledger  :accessor ledger  :initarg :ledger :type 'ledger)
   (legend  :accessor legend  :initarg :legend :type 'string)
   (date    :accessor date    :initarg :date   :type 'timestamp)
   (entries :accessor entries :initform (make-list 0))
   (posted  :reader   posted  :initform nil)
   )
  )
(defclass batch-entry ()
  ((account :accessor account :initarg :account :type 'string)
   (amount  :accessor amount  :initarg :amount  :type 'decimal)
   (debitp  :accessor debitp  :initarg :debitp)
   )
  )
(defmethod debitp ((self account))
  (not (null (position (char (account-number self) 0) "14")))
  )
(defmethod empty ((self account))
  (= 0 (length (entries self)))
  )
(defmethod account-named ((self account) name)
  (if (equalp name (name self))
      self
      (car (remove-if #'null
                      (mapcar #'(lambda (acc)
                                  (account-named acc name))
                              (children self))))
      )
  )
(defmethod account-number ((self account))
  (let ((parent (parent self)))
    (if parent
        (let (
              (parent-number (account-number parent))
              )
          (concatenate 'string parent-number
                       (format nil "~vd"
                               (1+ (floor 
                                    (log (number-of-subaccounts parent) 10)))
                               (1+ (position self (children parent))))))
        ""
        )
    )
  )
(defmethod number-of-subaccounts ((self account))
  (length (children self))
  )
(defmethod balance ((self account))
  (let ((debit-account (debitp self))
        (result 0)
        )
    (iter
      (for entry in-sequence (entries self))
      (setf result (funcall
                    (if (eq debit-account (debitp entry))
                        #'+ #'-)
                    result (amount entry))))
    result)
  )
(defun make-account (&key name parent &allow-other-keys)
  (make-instance 'account :name name :parent parent)
  )
(defmethod initialize-instance ((self account) &key parent &allow-other-keys)
  (call-next-method)
  (if parent
      (add-account-to-parent :account self :parent parent)
    )
  )
(defun add-account-to-parent (&key account parent)
  (setf (children parent)
        (push account (children parent)))
  )
(defun make-ledger (&key name)
  (let ((ledger (make-account :name name :parent nil))
        )
    (iter
      (for cat in-sequence
           (reverse #("Assets" "Liabilities" "Equity" "Income" "Expenses")))
      (make-account :name cat :parent ledger))
    ledger)
  )
(defparameter +line-length+ 80)
(defmethod print-object ((self account) stream)
  (let ((children (children self))
        (name (name self))
        (account-number (account-number self))
        )
    (if children
        (progn
          (format stream "~&~a ~a" account-number  name)
          (iter
           (for child in-sequence children)
           (print-object child stream)))
        (let ((debits nil)
              (credits nil)
              (lines))
          (format stream "~&~a~vt~a~&~a" account-number
                  (floor (/ (- +line-length+ (length name)) 2)) name
                  (make-string +line-length+ :initial-element #\_)
                  )
          (iter
            (for entry in-sequence (entries self))
            (if (debitp entry)
              (setf debits (append debits (list entry)))
              (setf credits (append credits (list entry))))
            )
          (setf lines (max (length debits) (length credits)))
          (iter
            (for line from 1 to lines)
            (format stream "~&~@[~a~]~40t|~@[~a~]" (car debits) (car credits))
            (setf debits (cdr debits))
            (setf credits (cdr credits))
            )
          )
        )
    )
  )
(defmethod print-object ((self account-entry) stream)
  (format stream "~a ~a ~/wu-decimal:$/"
          (format-timestring nil (date self) :format +rfc3339-format/date-only+)
          (legend self) (amount self))
  )
(defmethod in-balance ((self batch))
  (let ((debit-sum 0)
        (credit-sum 0)
        )
    (iter
      (for entry in (entries self))
      (if (debitp entry)
          (setf debit-sum (+ debit-sum (amount entry)))
          (setf credit-sum (+ credit-sum (amount entry)))
          )
      )
    (equal debit-sum credit-sum)
    )
  )
(defun make-account-entry (&key amount date debitp legend &allow-other-keys)
  (make-instance 'account-entry :amount amount :date date :debitp debitp
                 :legend legend)
  )
(defun post-entry (account entry)
  (if (posted entry)
      (error "entry ~a is already posted to account ~a" entry account))
  (setf (entries account) (merge 'list (entries account) (list entry)
                                 #'timestamp< :key #'date)
        (posted entry) t
        )
  )
(defun post-batch (self ledger)
  (if (or (posted self) (not (in-balance self)))
      (error "Cannot post batch ~a" self))
  (iter
    (for entry in-sequence (entries self))
    (post-entry (account-named ledger (account entry))
                (make-account-entry :amount (amount entry)
                                    :debitp (debitp entry)
                                    :legend (legend self)
                                    :date   (date self)))
    )
  (setf (slot-value self 'posted) t)
  )
(defun make-batch (&key ledger legend date)
  (make-instance 'batch :ledger ledger :legend legend :date date)
  )
(defun make-transaction (&key account debitp amount)
  (make-instance 'batch-entry :account account :debitp debitp :amount amount)
  )
(defun add (&key transaction batch)
  (if (member-if #'(lambda (tran)
                     (eq (account tran) (account transaction)))
                  (entries batch))
       (error "Transaction ~a already in batch ~a" transaction batch))
  (setf (entries batch) (push transaction (entries batch)))
  )
(defmethod hash ((self batch))
  (iter
    (for entry in-sequence (entries self))
    (sum (amount entry) into x)
    (finally (return x))
    )
  )
(defmethod empty ((self journal))
  t
  )
(defun make-journal (&key ledger)
  (make-instance 'journal :ledger ledger)
  )
